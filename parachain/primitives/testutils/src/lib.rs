use ethereum_types::{H128, H256, H512};
use serde::{Deserialize, Deserializer};
use std::{fs::File, path::Path};

/// The structs defined below are used to load Ethash merkle proofs
/// generated by https://github.com/talbaneth/ethashproof.
/// To generate proof JSON:
///     ./cmd/relayer/relayer $BLOCK_NUM
/// To load in test:
///     $proof_data = BlockWithProofs::from_file("path/to/proof.json")
///         .to_double_node_with_merkle_proof_vec();

#[derive(Clone)]
pub struct Hex(pub Vec<u8>);

impl<'de> Deserialize<'de> for Hex {
	fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
	where
		D: Deserializer<'de>,
	{
		let mut s = <String as Deserialize>::deserialize(deserializer)?;
		if s.starts_with("0x") {
			s = s[2..].to_string();
		}
		if s.len() % 2 == 1 {
			s.insert_str(0, "0");
		}
		let v: Vec<u8> = hex::FromHexIter::new(&s).map(|x| x.unwrap()).collect();
		Ok(Hex(v))
	}
}

impl From<&Hex> for H256 {
	fn from(item: &Hex) -> Self {
		let mut data = [0u8; 32];
		let size = item.0.len();
		for i in 0..size {
			data[31 - i] = item.0[size - 1 - i];
		}
		data.into()
	}
}

impl From<&Hex> for H128 {
	fn from(item: &Hex) -> Self {
		let mut data = [0u8; 16];
		let size = item.0.len();
		for i in 0..size {
			data[15 - i] = item.0[size - 1 - i];
		}
		data.into()
	}
}

#[derive(Deserialize)]
struct BlockWithProofsRaw {
	pub proof_length: u64,
	pub header_rlp: Hex,
	pub merkle_root: Hex,        // H128
	pub elements: Vec<Hex>,      // H256
	pub merkle_proofs: Vec<Hex>, // H128
}

pub struct BlockWithProofs {
	pub proof_length: u64,
	pub header_rlp: Hex,
	pub merkle_root: H128,
	pub elements: Vec<H256>,
	pub merkle_proofs: Vec<H128>,
}

impl From<BlockWithProofsRaw> for BlockWithProofs {
	fn from(item: BlockWithProofsRaw) -> Self {
		Self {
			proof_length: item.proof_length,
			header_rlp: item.header_rlp,
			merkle_root: (&item.merkle_root).into(),
			elements: item.elements.iter().map(|e| e.into()).collect(),
			merkle_proofs: item.merkle_proofs.iter().map(|e| e.into()).collect(),
		}
	}
}

impl BlockWithProofs {
	pub fn from_file(path: &Path) -> Self {
		let raw: BlockWithProofsRaw = serde_json::from_reader(File::open(path).unwrap()).unwrap();
		raw.into()
	}

	fn combine_dag_h256_to_h512(elements: Vec<H256>) -> Vec<H512> {
		elements
			.iter()
			.zip(elements.iter().skip(1))
			.enumerate()
			.filter(|(i, _)| i % 2 == 0)
			.map(|(_, (a, b))| {
				let mut buffer = [0u8; 64];
				buffer[..32].copy_from_slice(&(a.0));
				buffer[32..].copy_from_slice(&(b.0));
				buffer.into()
			})
			.collect()
	}

	pub fn to_double_node_with_merkle_proof_vec<T>(
		&self,
		mapper: fn([H512; 2], Vec<H128>) -> T,
	) -> Vec<T> {
		let h512s = Self::combine_dag_h256_to_h512(self.elements.clone());
		h512s
			.iter()
			.zip(h512s.iter().skip(1))
			.enumerate()
			.filter(|(i, _)| i % 2 == 0)
			.map(|(i, (a, b))| {
				mapper(
					[*a, *b],
					self.merkle_proofs[i / 2 * self.proof_length as usize..
						(i / 2 + 1) * self.proof_length as usize]
						.to_vec(),
				)
			})
			.collect()
	}
}
