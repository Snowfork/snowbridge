package parachain

import (
	"context"
	"fmt"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/snowfork/go-substrate-rpc-client/v3/types"
	"github.com/snowfork/snowbridge/relayer/chain/parachain"
	"github.com/snowfork/snowbridge/relayer/chain/relaychain"
	"github.com/snowfork/snowbridge/relayer/contracts/basic"
	"github.com/snowfork/snowbridge/relayer/contracts/incentivized"
	"github.com/snowfork/snowbridge/relayer/crypto/merkle"

	log "github.com/sirupsen/logrus"
)

// Catches up by searching for and relaying all missed commitments before the given para block
// This method creates proofs based on the mmr root at the specific given relaychainBlock and so
// the proofs will need to be verified by the mmr root for that relay chain block
func (li *BeefyListener) buildMissedMessagePackages(
	ctx context.Context,
	polkadotBlockNumber uint64,
	polkadotBlockHash types.Hash,
	paraBlock uint64,
	paraHash types.Hash,
) ([]*Task, error) {
	basicContract, err := basic.NewBasicInboundChannel(common.HexToAddress(
		li.config.Contracts.BasicInboundChannel),
		li.ethereumConn.GetClient(),
	)
	if err != nil {
		return nil, err
	}

	incentivizedContract, err := incentivized.NewIncentivizedInboundChannel(common.HexToAddress(
		li.config.Contracts.IncentivizedInboundChannel),
		li.ethereumConn.GetClient(),
	)
	if err != nil {
		return nil, err
	}

	options := bind.CallOpts{
		Pending: true,
		Context: ctx,
	}

	ethBasicNonce, err := basicContract.Nonce(&options)
	if err != nil {
		return nil, err
	}
	log.WithFields(log.Fields{
		"nonce": ethBasicNonce,
	}).Info("Checked latest nonce delivered to ethereum basic channel")

	ethIncentivizedNonce, err := incentivizedContract.Nonce(&options)
	if err != nil {
		return nil, err
	}
	log.WithFields(log.Fields{
		"nonce": ethIncentivizedNonce,
	}).Info("Checked latest nonce delivered to ethereum incentivized channel")

	paraBasicNonceKey, err := types.CreateStorageKey(li.parachainConnection.Metadata(), "BasicOutboundModule", "Nonce", nil, nil)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	var paraBasicNonce types.U64
	ok, err := li.parachainConnection.API().RPC.State.GetStorage(paraBasicNonceKey, &paraBasicNonce, paraHash)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	if !ok {
		paraBasicNonce = 0
	}
	log.WithFields(log.Fields{
		"nonce": uint64(paraBasicNonce),
	}).Info("Checked latest nonce generated by parachain basic channel")

	paraIncentivizedNonceKey, err := types.CreateStorageKey(li.parachainConnection.Metadata(), "IncentivizedOutboundModule", "Nonce", nil, nil)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	var paraIncentivizedNonce types.U64
	ok, err = li.parachainConnection.API().RPC.State.GetStorage(paraIncentivizedNonceKey, &paraIncentivizedNonce, paraHash)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	if !ok {
		paraIncentivizedNonce = 0
	}
	log.WithFields(log.Fields{
		"nonce": uint64(paraIncentivizedNonce),
	}).Info("Checked latest nonce generated by parachain incentivized channel")

	if ethBasicNonce == uint64(paraBasicNonce) && ethIncentivizedNonce == uint64(paraIncentivizedNonce) {
		return nil, nil
	}

	log.Info("Nonces are not all up to date - searching for lost commitments")

	tasks, err := li.scanForCommitments(paraBlock, ethBasicNonce, ethIncentivizedNonce)
	if err != nil {
		return nil, err
	}

	log.Info("Stopped searching for lost commitments")

	log.WithFields(log.Fields{
		"tasks": tasks,
	}).Info("Found these tasks")

	li.gatherProofInputs(polkadotBlockNumber, polkadotBlockHash, tasks)

	return tasks, nil
}

func (li *BeefyListener) gatherProofInputs(
	polkadotBlockNumber uint64,
	polkadotBlockHash types.Hash,
	tasks []*Task,
) error {
	api := li.relaychainConn.API()

	// build mapping: Parachain block number -> Task
	items := make(map[uint64]*Task)
	for _, task := range tasks {
		items[task.BlockNumber] = task
	}

	for len(items) > 0 && polkadotBlockNumber > 0 {
		paraHeads, err := li.relaychainConn.FetchParaHeads(polkadotBlockHash)
		if err != nil {
			return err
		}

		if _, ok := paraHeads[li.paraID]; !ok {
			return fmt.Errorf("snowbridge is not a registered parachain")
		}

		paraHeadsAsSlice := make([]relaychain.ParaHead, 0, len(paraHeads))
		for _, v := range paraHeads {
			paraHeadsAsSlice = append(paraHeadsAsSlice, v)
		}

		var snowbridgeHeader types.Header
		if err := types.DecodeFromBytes(paraHeads[li.paraID].Data, &snowbridgeHeader); err != nil {
			log.WithError(err).Error("Failed to decode Header")
			return err
		}

		snowbridgeBlockNumber := uint64(snowbridgeHeader.Number)

		if task, ok := items[snowbridgeBlockNumber]; ok {
			task.ProofInput = &ProofInput{
				polkadotBlockNumber,
				paraHeadsAsSlice,
			}
			delete(items, snowbridgeBlockNumber)
		}

		polkadotBlockNumber--
		polkadotBlockHash, err = api.RPC.Chain.GetBlockHash(polkadotBlockNumber)
		if err != nil {
			return err
		}
	}

	if len(items) > 0 {
		return fmt.Errorf("Could not gather all proof inputs")
	}

	return nil
}

func (li *BeefyListener) generateProof(ctx context.Context, input *ProofInput) (*ProofOutput, error) {

	polkadotBlockNumber, polkadotBlockHash, err := li.fetchLatestBeefyBlock(ctx)
	if err != nil {
		log.WithError(err).Error("Failed to get latest relay chain block number and hash")
		return nil, err
	}

	mmrProof, err := li.relaychainConn.GetMMRLeafForBlock(
		polkadotBlockNumber + 1,
		polkadotBlockHash,
		li.config.Polkadot.BeefyStartingBlock,
	)
	if err != nil {
		log.WithError(err).Error("Failed to get mmr leaf")
		return nil, err
	}

	simplifiedProof, err := merkle.ConvertToSimplifiedMMRProof(
		mmrProof.BlockHash,
		uint64(mmrProof.Proof.LeafIndex),
		mmrProof.Leaf,
		uint64(mmrProof.Proof.LeafCount),
		mmrProof.Proof.Items,
	)
	if err != nil {
		log.WithError(err).Error("Failed to simplify mmr proof")
		return nil, err
	}

	mmrRootHashKey, err := types.CreateStorageKey(li.relaychainConn.Metadata(), "Mmr", "RootHash", nil, nil)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	var mmrRootHash types.Hash
	ok, err := li.relaychainConn.API().RPC.State.GetStorage(mmrRootHashKey, &mmrRootHash, polkadotBlockHash)
	if err != nil {
		log.Error(err)
		return nil, err
	}
	if !ok {
		return nil, fmt.Errorf("could not get mmr root hash")
	}

	merkleProofData, err := CreateParachainMerkleProof(input.ParaHeads, li.paraID)
	if err != nil {
		log.WithError(err).Error("Failed to create parachain header proof")
		return nil, err
	}

	if merkleProofData.Root.Hex() != mmrProof.Leaf.ParachainHeads.Hex() {
		err = fmt.Errorf("MMR parachain merkle root does not match calculated parachain merkle root - calculated: %s, mmr: %s", merkleProofData.Root.String(), mmrProof.Leaf.ParachainHeads.Hex())
		log.WithError(err).Error("Failed to create parachain merkle root")
		return nil, err
	}

	log.Debug("Created all parachain merkle proof data")

	output := ProofOutput {
		MMRProof: simplifiedProof,
		MMRRootHash: mmrRootHash,
		MerkleProofData: merkleProofData,
	}

	return &output, nil
}

// Searches for all lost commitments on each channel from the given parachain block number backwards
// until it finds the given basic and incentivized nonce
func (li *BeefyListener) scanForCommitments(
	lastParaBlockNumber uint64,
	basicNonceToFind uint64,
	incentivizedNonceToFind uint64,
) ([]*Task, error) {
	log.WithFields(log.Fields{
		"basicNonce":        basicNonceToFind,
		"incentivizedNonce": incentivizedNonceToFind,
		"latestblockNumber": lastParaBlockNumber,
	}).Debug("Searching backwards from latest block on parachain to find block with nonce")

	currentBlockNumber := lastParaBlockNumber + 1
	basicNonceFound := false
	incentivizedNonceFound := false

	var tasks []*Task

	for (!basicNonceFound || !incentivizedNonceFound) && currentBlockNumber > 0 {
		currentBlockNumber--
		log.WithFields(log.Fields{
			"blockNumber": currentBlockNumber,
		}).Debug("Checking header...")

		blockHash, err := li.parachainConnection.API().RPC.Chain.GetBlockHash(currentBlockNumber)
		if err != nil {
			log.WithFields(log.Fields{
				"blockNumber": currentBlockNumber,
			}).WithError(err).Error("Failed to fetch blockhash")
			return nil, err
		}

		header, err := li.parachainConnection.API().RPC.Chain.GetHeader(blockHash)
		if err != nil {
			log.WithError(err).Error("Failed to fetch header")
			return nil, err
		}

		digestItems, err := parachain.ExtractAuxiliaryDigestItems(header.Digest)
		if err != nil {
			return nil, err
		}

		commitments := make(map[parachain.ChannelID]Commitment)

		for _, digestItem := range digestItems {
			if !digestItem.IsCommitment {
				continue
			}
			channelID := digestItem.AsCommitment.ChannelID
			if channelID.IsBasic && !basicNonceFound {
				isRelayed, messageData, err := li.checkBasicMessageNonces(&digestItem, basicNonceToFind)
				if err != nil {
					return nil, err
				}
				if !isRelayed {
					var messages []parachain.BasicOutboundChannelMessage
					err := types.DecodeFromBytes(messageData, &messages)
					if err != nil {
						log.WithError(err).Error("Failed to decode commitment messages")
						return nil, err
					}
					commitments[channelID] = Commitment{
						digestItem.AsCommitment.Hash,
						messages,
					}
				} else {
					basicNonceFound = true
				}
			}
			if channelID.IsIncentivized && !incentivizedNonceFound {
				isRelayed, messageData, err := li.checkIncentivizedMessageNonces(&digestItem, incentivizedNonceToFind)
				if err != nil {
					return nil, err
				}
				if !isRelayed {
					var messages []parachain.BasicOutboundChannelMessage
					err := types.DecodeFromBytes(messageData, &messages)
					if err != nil {
						log.WithError(err).Error("Failed to decode commitment messages")
						return nil, err
					}
					commitments[channelID] = Commitment{
						digestItem.AsCommitment.Hash,
						messages,
					}
				} else {
					incentivizedNonceFound = true
				}
			}
		}

		if len(commitments) > 0 {
			task := Task{
				ParaID: li.paraID,
				BlockNumber: currentBlockNumber,
				Header: header,
				Commitments: commitments,
				ProofInput: nil,
				ProofOutput: nil,
			}
			tasks = append(tasks, &task)
		}
	}

	return tasks, nil
}

func (li *BeefyListener) checkBasicMessageNonces(
	digestItem *parachain.AuxiliaryDigestItem,
	nonceToFind uint64,
) (bool, types.StorageDataRaw, error) {
	messages, data, err := li.parachainConnection.GetBasicOutboundMessages(*digestItem)
	if err != nil {
		return false, nil, err
	}

	for _, message := range messages {
		if message.Nonce <= nonceToFind {
			return true, data, nil
		}
	}
	return false, data, nil
}

func (li *BeefyListener) checkIncentivizedMessageNonces(
	digestItem *parachain.AuxiliaryDigestItem,
	nonceToFind uint64,
) (bool, types.StorageDataRaw, error) {

	messages, data, err := li.parachainConnection.GetIncentivizedOutboundMessages(*digestItem)
	if err != nil {
		return false, nil, err
	}

	for _, message := range messages {
		if message.Nonce <= nonceToFind {
			return true, data, nil
		}
	}
	return false, data, nil
}
