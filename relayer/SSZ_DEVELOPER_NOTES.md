# SSZ Developer Notes for Snowbridge Relayer

This document captures important knowledge about SSZ (Simple Serialize) handling in the Snowbridge relayer codebase, particularly for beacon chain state processing and Merkle proof generation.

## Table of Contents
1. [Overview](#overview)
2. [Key Files and Locations](#key-files-and-locations)
3. [SSZ Unmarshaling](#ssz-unmarshaling)
4. [Tree Hashing and Proof Generation](#tree-hashing-and-proof-generation)
5. [Memory Optimization](#memory-optimization)
6. [Critical SSZ Gotchas](#critical-ssz-gotchas)
7. [Fork-Specific Handling](#fork-specific-handling)

---

## Overview

The codebase uses **fastssz** (`github.com/ferranbt/fastssz`) for SSZ serialization. Beacon states are large (~300MB+ for mainnet) and require careful handling for:
- Deserializing state data from beacon nodes
- Building Merkle trees for proof generation
- Memory-efficient processing

---

## Key Files and Locations

### Beacon State Types
- `relays/beacon/state/beacon.go` - Core `BeaconState` interface
- `relays/beacon/state/beacon_deneb.go` - Deneb fork state
- `relays/beacon/state/beacon_electra.go` - Electra fork state
- `relays/beacon/state/beacon_fulu.go` - Fulu fork state

### Generated Encoding Files (Auto-generated by fastssz)
- `relays/beacon/state/beacon_encoding.go` - Core structures
- `relays/beacon/state/beacon_deneb_encoding.go` - Deneb fork
- `relays/beacon/state/beacon_electra_encoding.go` - Electra fork
- `relays/beacon/state/beacon_fulu_encoding.go` - Fulu fork

### Lite State Parser (Memory-Optimized)
- `relays/beacon-state/lite_state.go` - Lightweight beacon state struct
- `relays/beacon-state/lite_hash.go` - Streaming hash functions for large SSZ fields

### Service Integration
- `relays/beacon-state/service.go` - Beacon state service using SSZ
- `relays/beacon-state/handlers.go` - HTTP handlers for proof endpoints
- `relays/beacon/header/syncer/syncer.go` - Header syncer with state unmarshaling

---

## SSZ Unmarshaling

### BeaconState Interface
All beacon state types implement this interface:

```go
type BeaconState interface {
    UnmarshalSSZ(buf []byte) error
    GetTree() (*ssz.Node, error)
    GetSlot() uint64
    GetLatestBlockHeader() *BeaconBlockHeader
    GetBlockRoots() [][]byte
    GetFinalizedCheckpoint() *Checkpoint
    GetCurrentSyncCommittee() *SyncCommittee
    GetNextSyncCommittee() *SyncCommittee
}
```

### Unmarshaling Entry Point
Located in `syncer.go`, the `UnmarshalBeaconState()` method:
1. Determines fork version based on slot
2. Creates appropriate BeaconState struct (Deneb, Electra, or Fulu)
3. Calls `UnmarshalSSZ(data []byte)` on the selected state type

### SSZ Field Offsets
SSZ uses fixed offsets for fixed-size fields and offset pointers for variable-size fields:

**Fixed positions (Deneb/Electra):**
- `Slot`: bytes 40-48
- `LatestBlockHeader`: bytes 64-176
- `BlockRoots`: bytes 176-262320
- `FinalizedCheckpoint`: bytes 2687337-2687377
- `CurrentSyncCommittee`: bytes 2687381-2712005
- `NextSyncCommittee`: bytes 2712005-2736629

**Variable-size fields (stored as offset pointers):**
- `Validators` (~120MB)
- `Balances` (~8MB)
- `*EpochParticipation` (~2MB)
- `InactivityScores` (~8MB)

---

## Tree Hashing and Proof Generation

### GetTree() Usage
The `GetTree()` method builds a Merkle tree from the beacon state for proof generation:

```go
tree, err := beaconState.GetTree()
if err != nil {
    return err
}

// Compute root hash
root := tree.Hash()

// Generate proof for a specific generalized index
proof, err := tree.Prove(generalizedIndex)
```

### Generalized Indices
Proofs are generated using generalized indices that identify nodes in the Merkle tree:
- Finalized header proof
- Block root proof
- Sync committee proofs (current and next)

### Tree Operations in Service
- `service.go:673` - `preGenerateProofs()` generates Merkle tree
- `handlers.go:138-150` - `cacheAllProofs()` uses tree to generate proofs
- `client.go:119` - Builds block roots tree container

---

## Memory Optimization

### Problem
Full beacon state unmarshaling requires ~300MB+ of memory, which doubles when building the tree.

### Solution: LiteBeaconState
The lite parser extracts only what's needed for proof generation and computes hashes for everything else:

**Extracted fields (~5MB total):**
- `Slot`, `LatestBlockHeader`, `BlockRoots` (256KB)
- `FinalizedCheckpoint`, `CurrentSyncCommittee`, `NextSyncCommittee`

**Hashed fields (32 bytes each instead of full data):**
- `Validators` (~120MB) → 32-byte hash
- `Balances` (~8MB) → 32-byte hash
- `*EpochParticipation` (~2MB) → 32-byte hash
- `InactivityScores` (~8MB) → 32-byte hash
- `RandaoMixes` (~2MB) → 32-byte hash

**Memory savings: ~130MB+ per beacon state**

### Usage
```go
// Old way (full unmarshal, ~300MB+ memory):
beaconState, err := s.unmarshalBeaconState(slot, data)

// New way (lite unmarshal, ~170MB memory):
beaconState, err := s.unmarshalBeaconStateLite(slot, data)
```

---

## Critical SSZ Gotchas

### 1. SSZ List Merkleization Uses LIMIT, Not Actual Count

**Wrong:**
```go
// Pads to next power of 2 based on actual count
merkleize(chunks, len(chunks))
```

**Correct:**
```go
// Must use the SSZ limit to determine tree depth, then mix in length
merkleizeWithLimit(chunks, limit)
```

SSZ lists have a fixed tree depth determined by the **limit** (max capacity), not the actual element count. The length is then mixed into the root.

**SSZ Limits in Beacon State:**
- `Validators`: limit 2^40
- `Balances`: chunk limit 2^38 (2^40 / 4 since 4 uint64s per chunk)
- `Participation`: chunk limit 2^40 / 32
- `InactivityScores`: chunk limit 2^38
- `HistoricalSummaries`: limit 2^24
- `HistoricalRoots`: limit 2^24
- `Eth1DataVotes`: limit 2048
- `PendingDeposits`: limit 2^27
- `PendingPartialWithdrawals`: limit 2^27
- `PendingConsolidations`: limit 2^18

### 2. BLS Pubkeys and Signatures Must Be Chunked

SSZ requires byte arrays > 32 bytes to be chunked into 32-byte pieces and merkleized.

**48-byte BLS Pubkey:**
```go
// Wrong - simple hash
hash := sha256.Sum256(pubkeyPadded64Bytes)

// Correct - chunk and merkleize
chunk1 := pubkey[0:32]
chunk2 := make([]byte, 32)
copy(chunk2, pubkey[32:48]) // bytes 32-47, rest is zeros
result := hashTwo(chunk1, chunk2)
```

**96-byte BLS Signature:**
```go
// Wrong - simple hash
hash := sha256.Sum256(signature)

// Correct - 4 chunks (3 data + 1 zero padding) merkleized
chunk1 := signature[0:32]
chunk2 := signature[32:64]
chunk3 := signature[64:96]
chunk4 := make([]byte, 32) // zero padding
result := hashTwo(hashTwo(chunk1, chunk2), hashTwo(chunk3, chunk4))
```

### 3. Container Fields Produce Single 32-byte Roots

When building a container's Merkle tree, each field produces exactly **one** 32-byte field root, regardless of the field's size:
- Simple 32-byte field: used directly
- Multi-chunk fields (pubkey, signature): pre-merkleized to single root
- Lists/vectors: merkleized to single root

```go
// Each PutBytes/PutUint64/etc. adds ONE leaf to the tree
hh.PutBytes(v.Pubkey[:])      // 48 bytes → 1 leaf (internally merkleized)
hh.PutBytes(v.Signature[:])   // 96 bytes → 1 leaf (internally merkleized)
hh.PutUint64(v.Amount)        // 8 bytes → 1 leaf
```

### 4. ExecutionPayloadHeader Has Variable Fields

The `ExecutionPayloadHeader` contains variable-length `ExtraData`, so it needs proper SSZ merkleization, not just SHA256. Use the fastssz-generated `HashTreeRoot()` method:

```go
// Wrong
hash := sha256.Sum256(headerBytes)

// Correct - unmarshal and use generated method
header := &state.ExecutionPayloadHeaderDeneb{}
header.UnmarshalSSZ(headerBytes)
root, _ := header.HashTreeRoot()
```

### 5. Zero Hashes for Empty Subtrees

When merkleizing with limits, empty positions in the tree use precomputed zero hashes at each depth:

```go
var zeroHashes [64][32]byte

func init() {
    // zeroHashes[0] = [32]byte{0...}
    for i := 1; i < 64; i++ {
        zeroHashes[i] = hashTwo(zeroHashes[i-1][:], zeroHashes[i-1][:])
    }
}
```

---

## Fork-Specific Handling

### Supported Forks
1. **Deneb** - Base fork
2. **Electra** - Adds pending deposits, withdrawals, consolidations
3. **Fulu** - Latest fork (uses Electra parser with same structure)

### Fork Detection
```go
func (s *Syncer) GetForkVersion(slot uint64) int {
    epoch := slot / s.settings.SlotsInEpoch

    if epoch >= s.settings.ForkVersions.Fulu {
        return protocol.Fulu
    }
    if epoch >= s.settings.ForkVersions.Electra {
        return protocol.Electra
    }
    return protocol.Deneb
}
```

### Electra/Fulu Additions
These forks add new list fields that must be properly merkleized with their limits:
- `PendingDeposits` (limit 2^27)
- `PendingPartialWithdrawals` (limit 2^27)
- `PendingConsolidations` (limit 2^18)

### Routing in Lite Parser
```go
if forkVersion == protocol.Fulu || forkVersion == protocol.Electra {
    liteState, err := UnmarshalSSZLiteElectra(data)
    // ...
} else {
    liteState, err := UnmarshalSSZLiteDeneb(data)
    // ...
}
```

---

## Quick Reference

### Generating Proofs
```go
// 1. Get beacon state
data, _ := client.GetBeaconState(slot)

// 2. Unmarshal (lite for memory efficiency)
state, _ := UnmarshalSSZLiteElectra(data)

// 3. Build tree
tree, _ := state.GetTree()

// 4. Generate proof
proof, _ := tree.Prove(generalizedIndex)
```

### Common Generalized Indices
- Finalized checkpoint: calculated from beacon state schema
- Block roots: vector at specific field index
- Sync committees: current and next at their field indices

### Testing SSZ Parsing
```go
func TestLiteVsFull(t *testing.T) {
    data, _ := os.ReadFile("testdata/beacon_state.ssz")

    // Full parse
    fullState := &state.BeaconStateElectra{}
    fullState.UnmarshalSSZ(data)
    fullTree, _ := fullState.GetTree()
    fullRoot := fullTree.Hash()

    // Lite parse
    liteState, _ := UnmarshalSSZLiteElectra(data)
    liteTree, _ := liteState.GetTree()
    liteRoot := liteTree.Hash()

    // Must match exactly
    assert.Equal(t, fullRoot, liteRoot)
}
```

---

## Resources

- [SSZ Specification](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md)
- [fastssz Library](https://github.com/ferranbt/fastssz)
- [Ethereum Beacon Chain Spec](https://github.com/ethereum/consensus-specs)
